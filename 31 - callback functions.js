"use strict";

function first() {
  //Do smth
  // Эта функция имеет какую то задержку, например сервер ответит через полсекунды.
  setTimeout(function () {
    console.log(1);
  }, 500);
}

function second() {
  console.log(2); //без задержки
}
first(); //возможно так, что задержка не видна сразу, и вызовятся функции не так, как мы предполагаем, особенно, если работают с одними и теми же данными.
second();

//callback-функция - функция, которая должна быть выполнена, после того, как другая завершила свое выполнение.

// function learnJS(lang, callback) {
//   setTimeout(function () {
//     console.log(`Я повторяю: ${lang}`);
//     callback();
//   }, 500);
// }
function learnJS(lang, callback) {
  console.log(`Я повторяю: ${lang}`);
  callback();
}

function done() {
  console.log("пупупу");
}
// получается, что после выполнения первой функции,
// строго после этого выполнится вторая
learnJS("Js", done); //после того как завершится первая функция, выполнится следующая
//внутри анонимная функция, она исчезнет и к ней нельзя будет обратиться
//без открытых скобок, тк передали как аргемент, а выполняется внутри learnJS
//при запросе к серверу коллбек используется постоянно
//или например первым аргументом передаем клик,
//и функция коллбек выполняется строго после клика.

//есть какие то данные, которые надо обработать
//сразу делаем шаблон функции, получаем юрл,
//получаем данные, и вызываем функцию,
//которая будет отвечать за обработку данных
//получается очень удобно для чтения и структурированно
function getData(url, callback) {
  // Имитация асинхронного запроса к серверу
  setTimeout(() => {
    const responseData = "загруженные данные"; // Данные, полученные от сервера
    callback(responseData); // Вызов коллбэка с полученными данными
  }, 1000);
}

function processData(data) {
  console.log("Обработка данных:", data);
}

// Вызов функции с коллбэком
getData("https://example.com/data", processData); //в одной функции, ПРИШЛА ИНФА СРАЗУ ОБРАБОТАЛИ

//set time out в любом случае предоставляет ассинхронность и не блокирует последующий поток кода (если этот поток не структурирован конкретно в коллбек функции окторая передается в settimeout)

//Пример 2: Обработка событий в браузере
// Коллбэки широко используются для обработки событий в браузере. Например, мы хотим выполнить некоторый код после клика по кнопке:
function onButtonClick() {
  alert("Кнопка была нажата!");
}
document.getElementById("myButton").addEventListener("click", onButtonClick);
// Коллбэки также используются с таймерами для выполнения кода после задержки:
function timeoutCallback() {
  console.log("Прошло 2 секунды");
}

// Установка таймера
setTimeout(timeoutCallback, 2000);
