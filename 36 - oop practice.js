/* 
ооп - один из подходов программирования. 
один из стилей ооп - прототипно ориентированное программирование.
Js является объектно ориентированным языком.

Например, у машины есть свойстваЖ двигатель, кузов и тд.
Методы: езда, перевозка людей и тд, что он умеет делать.
Смысл ооп - представляем любую вещи как объект.

Строка, например, находясь просто в кавычках - это обычный примитив, простой тип данных,
но когда вызываем метод или свойство, js оборачивает эту строку в объект и после модификации возвращает в 
строку. 

Когда вы используете конструктор new String(), вы создаете новый объект String. Этот объект оборачивает примитивное 
строковое значение, предоставляя ему свойства и методы объекта. Однако, тип этого нового значения будет 'object', а не 'string'
*/
let str = "some";
let strObj = new String(str); //так не следует в обычной практике создавать строку, это для наглядного примера. На основании str создали строку.
strObj.pro = "bar";
console.log(typeof str); //string
console.log(typeof strObj); //object
// если вывести просто strObj, [String: 'some'] указывает на то, что это объект String со значением 'some', ему можно добавлять какие то свойства и тд, обычный примитив не может хрантить подобные свойства.
//для использования скриптов, фреймворков и тд это будет полезно.

//есть допустим легковые автомобили, это будет прототип, от которого можно делать новые экземпляры. Будут разные свойства, но у каждого автомобиля.

/* 
когда создаем строки, или массивы, все они могут содержать разное наполнение, но обладают теми же методами,
когда создаем новый массив, мы создаем новый экземпляр прототипа массив.
*/

console.dir([1, 2, 3]); //в браузере будет Array(3), раскрываем, там будут индексы и элементы, а потом __proto__: Array(0), который можно раскрыть, это и есть прототип, там будут методы массива, если пройтись по ним то там будет в итоге еще один прототип, а именно __proto__: Object.

/* 
и так пройдясь по дереву proto можно убедиться, что объект - главная структура.

Те методы, которых нет в массве, но беруться у экземпляров массивов на самом деле приходят из объекта. Например, toString и тд и в случае чего на нижнем
уровне переопределить 
*/

//в реальных проектах будем создавать объекты, которые прототипно будут наследоваться друг от друга. Структура как в notion будет создаваться мной.

//наш прототип солдата
const soldier = {
  health: 400,
  armor: 100,
  sayHello: function () {
    console.log("Hello");
  },
};

//экземпляр прототипа
const jonh = {
  health: 100,
};

//jonh.__proto__ = soldier; Это устаревшая запись, установили прототип соладат для джона
Object.setPrototypeOf(jonh, soldier); //новая запись, первый аргумент кому, второй какой прототип
console.log(jonh);
jonh.sayHello();
//{ health: 100 } изначально есть только health. НО.

console.log(jonh.armor); //то есть некоторые свойства берутса из прототипов, также и тут.
/* 
В вебдеве: можем создать один прототип, например модального окна, которое содержит определенное
свойство, ширина, высота, какой то функционал, что при клике на крестик окно закрывается,
и от этого прототипа можно будет создавать другие модальные окна, если понадобится использовать
какие то методы от прототипа.
*/

//более современная запись НИЖЕ, где сразу создали объект
const soldier = {
  health: 400,
  armor: 100,
  sayHello: function () {
    console.log("Hello");
  },
};

// на практике сразу знаем что будет какой то основной прототип и его экземпляры.
const jonh = Object.create(soldier); //создали объект! джон будет прототипно наследоваться от солдата
jonh.armor = 500;
console.log(jonh.__proto__.armor);
