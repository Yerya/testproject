"use strict";
const obj = new Object(); //так лучше не создавать объект

const options = {
  name: "test",
  width: 1024,
  height: 1024,
  colors: {
    border: "black",
    bg: "red", //background
  },
  makeTest: function () {
    console.log("Test"); //создали свой свой собственный метод
  },
};

/*
деструктуризация объекта ниже, чтобы не заниматься двойным доступом и тд.
Будем доставать вложенные свойства в качестве отдельных структур, коробочек, которые будем отдельно выносить и дальше с ними работать.
 */
const { border, bg } = options.colors; //внутрь фигурных скобок помещаем переменные, которые хотим вытащить, а после присваивания пишем ту структуру, откуда хотим вытащить свойства, то есть деструктурировали.
console.log(border, bg);

options.makeTest(); //запустили созданный метод
console.log(console.log("андефайнд будет")); //любая функция если не писать явно return Или она не возвращает сама что то, будет возвращать undefined

//Ниже чтоб понимать суть
//пример двойного доступа ниже, достучались до black
console.log(options["colors"]["border"]);
console.log(typeof options.colors);
console.log(options.name);
//удалить пару ключ значение, с помощью оператора delete, напоминаю, несмотря на const это у нас ссылка на объект в памяти, саму ссылку мы не меняем.
delete options.name;
// в будущем можем создавать цикл, котрый по определенным параметрам будет удалять свойства из того или иного объекта;
console.log(options);

/*
чтобы перебрать свойства в объекте, 
можно использовать for in, также как с шкафом с вещами, можно
перебрать в нем вещи и посмотреть что завалялось и что мы с ними можем сделать.

свойство мы обозначаем каким нибудь ключевым словом, key
 */
//тут как и в обычном цикле, задаем какие то действия, которые будут повторяться каждый раз.
//работать будет столько раз, сколько свойсв у нас в объекте.

// for (let key in options) {
//   console.log(`Свойство ${key} имеет значение ${options[key]}`);
// }

// Свойство width имеет значение 1024
// Свойство height имеет значение 1024
// Свойство colors имеет значение [object Object] (P.S: одним из свойств объекта является тоже объект, когда js натыкается на него он не может преобразовать это в объект, поэтому записывает в формате object Object)
//for of для объектоов нельзя использовать

//можно задавать спец условия внутри, то есть перебор внутри перебора.
let counter = 0;

for (let key in options) {
  if (typeof options[key] === "object") {
    //тк значение colors И есть объект
    for (let subkey in options[key]) {
      //обращаемся к объекту внутри options
      console.log(
        `В объекте ${key} cвойство ${subkey} имеет значение ${options[key][subkey]}`
      ); //[key][subkey] тк свойство внутри свойства, чтобы достучаться до значения
    }
  } else {
    console.log(`Свойство ${key} имеет значение ${options[key]}`);
    counter++;
  }
}
//с рекурсией будет тоже самое, но для функций

//у объекта нет length, чтоб посмотреть количество свойств, самое простое решение - перебрать и записать в переменную. Прием счетчика

console.log(counter); //выведет 2, тк когда дошли до объекта его не засчитал, пошло по другой вилке. поэтому только высота и шириина попали, name удаляли

// Способ выше неудобен, но у объекта есть метод Object.keys(), то есть ключи объекта.
console.log(Object.keys(options).length);
/*
Этот метод берет наш объект, и на его основании создает массив, в котором
все элементы - ключи, находящиеся на первом уровне вложенности.
А уже для массива можно использовать length (как и для строк), чтобы посчитать количество.
 */
