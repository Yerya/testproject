//рекурсия и перебор
//рекурсия - когда функция вызывается внутри себя же.
//для примера возвидение в степень

//ниже без рекурсии с циклом.
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    //выполняется n раз, на каждом шаге умножая на наше число, присваивая в один результат. то есть например 2 в 3 степени, 1 * 2, 2 * 2, 4 * 2
    result *= x; //result = result * x;
  }
  return result;
}
const result = pow(2, 2);
console.log(result);

//вместо цикла можно вызывать ту же функцию

function pow(x, n) {
  if (n === 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

//в случае если pow(2,2):
/* 
Вместо x двойка, умножаем на результат возвидения
двойки на n-1, то есть 1. Получается будет возведение
в степень двойки на 2 в степени 1, это 2. Умножаем, 4.

то есть x * pow(x, n - 1) вычисляет тоже самое, но на степень меньше,
и будет вложенность функций если дальше будет идти.

Давайте разберем, как работает рекурсивная функция `pow(x, n)` на примере `pow(2, 3)`:

1. Вызов функции `pow(2, 3)` проверяет, равен ли `n` единице. Поскольку `n` равно 3, условие не выполняется, и функция переходит к следующему шагу.
2. Функция возвращает произведение `x` и результата вызова `pow(x, n - 1)`, то есть `2 * pow(2, 2)`.
3. Теперь необходимо вычислить `pow(2, 2)`. Этот вызов снова проверяет, равен ли `n` единице. Поскольку `n` равно 2, условие не выполняется, и функция возвращает `2 * pow(2, 1)`.
4. Следующий вызов `pow(2, 1)` проверяет условие `n === 1`, которое на этот раз выполняется, и функция возвращает `2`.
5. Теперь мы можем вычислить предыдущий шаг `2 * pow(2, 1)`, который равен `2 * 2 = 4`.
6. Возвращаемся к шагу `2 * pow(2, 2)`, который теперь равен `2 * 4 = 8`.
7. Итак, исходный вызов `pow(2, 3)` возвращает `8`.

В итоге, рекурсивные вызовы функции `pow` строят цепочку умножений, которая разворачивается обратно, когда достигается базовый случай (когда `n` равно 1). Это приводит к последовательному умножению `x` на себя `n` раз.

*/

//как n === 1 это база рекурсии, мы сводим к ней рекурсию, на ней она завершится

//n-1 это шаг рекурсии, должен какой то аргумент упрощаться

//глубина рекурсии - общее количества вызова функции вместе с самым первым

//циклом обычно эффективнее

//но большинство склоняются к рекурсии

//ниже очень удобно, есть одна структура объекта, где можно посмотреть кто к какому курсу относится js или html, есть каждый отдельный студент с именем и прогрессом.
let students = {
  js: [
    {
      name: "John",
      progress: 100,
    },
    {
      name: "Ivan",
      progress: 60,
    },
  ],
  html: {
    basic: [
      {
        name: "Peter",
        progress: 20,
      },
      {
        name: "Ann",
        progress: 18,
      },
    ],
    pro: [
      {
        name: "Sam",
        progress: 10,
      },
    ],
  },
};

//стоит задача посчитать средний процент прогресса со всех курсов.
//можно сделать через цикл или через рекурсию

//надо посчитать сколько вообще студентов и общее число в процентах, потом берем обещее число
//и делим на количество студентов.

function getTotalProgressByIteration(data) {
  //какие то данные приходят, пока не знаем какая
  let total = 0;
  let students = 0;

  //должны зайти в каждое свойство внутри и посчитать данные.
  //есть метод Object.values, возвращает массив с значениями объекта.
  for (let course of Object.values(data)) {
    //формируется один массив с 2мя значениями, массивом и объектом, course и будет этим массивом либо объектом
    //будет развилка, тк раюботаем либо с объектом либо с массивом
    if (Array.isArray(course)) {
      //используем метод Array.isArray() для проверки массив ли это, возвращает если то что передали это массив. тк если использовать typeof, скорее всего получим object
      //если это массив, должны посчитать количество студентов в массиве, и сложить свойства.
      students += course.length;

      for (let i = 0; i < course.length; i++) {
        total += course[i].progress; //получили доступ к значению прогресс и сложили в total;
      }
    } else {
      //вторая часть, когда попадаем на объект, нужно тоже посмотреть что внутри
      //опять через Object.values можно посмотреть значения
      for (let subCourse of Object.values(course)) {
        students += subCourse.length;
        for (let i = 0; i < subCourse.length; i++) {
          total += subCourse[i].progress; //получили доступ к значению прогресс и сложили в total;
        }
      }
    }
  }
  return total / students;
}

console.log(getTotalProgressByIteration(students));

//но так как код может усложняться и не совсем такую структуру хранить, можно использовать рекурсию

let students = {
  js: [
    {
      name: "John",
      progress: 100,
    },
    {
      name: "Ivan",
      progress: 60,
    },
  ],
  html: {
    basic: [
      {
        name: "Peter",
        progress: 20,
      },
      {
        name: "Ann",
        progress: 18,
      },
    ],
    pro: [
      {
        name: "Sam",
        progress: 10,
      },
    ],
  },
};

function getTotalProgressByRecutsion(data) {
  //базой рекурсии будет массив, тк как только натыкаемся на массив, там будет объект со студентами.
  if (Array.isArray(data)) {
    let total = 0;
    //используем метод Array.isArray() для проверки массив ли это, возвращает если то что передали это массив. тк если использовать typeof, скорее всего получим object
    //если это массив, должны посчитать количество студентов в массиве, и сложить свойства.

    //когда используем рекурсию, нет промежуточных элементов.

    for (let i = 0; i < data.length; i++) {
      total += data[i].progress; //получили доступ к значению прогресс и сложили в total;
    }

    return [total, data.length]; //надо вернуть какое то значение, если бы просто тотал то все было бы просто и просто return total, Но надо несколько, через запятую неправильно. Можно массив вернуть
  } else {
    //тут сама рекурсия, попадаем на объект и внутри будем перебирать
    let total = [0, 0]; //промежуточные значения

    for (let subData of Object.values(data)) {
      //должны саму же функцию запустить на этих данных, попали на внутреннее свойство и для каждого объекта или массива заново запускаем функцию, которая обрабатывает ее. То есть распространяем действие функции на внутренние структуры.
      const subDataArr = getTotalProgressByRecutsion(subData);
      total[0] += subDataArr[0]; //нулевой индекс это общее значение
      total[1] += subDataArr[1]; //общее количество студентов, которых будем увеличивать в итоге.
    }
    return total;
  }
}

const result = getTotalProgressByRecutsion(students);
console.log(result[0] / result[1]); //чтобы получить среднее значение

/*
Рекурсия в данном коде работает следующим образом:

1. **База рекурсии**: База рекурсии — это условие, при котором рекурсия прекращается. В данном случае базой рекурсии является массив. Если функция `getTotalProgressByRecutsion` получает на вход массив, она считает общий прогресс и количество студентов в этом массиве, а затем возвращает эти значения в виде массива. Это происходит в первой ветке условного оператора `if`.

2. **Шаг рекурсии**: Шаг рекурсии — это действие, которое функция выполняет при каждом рекурсивном вызове. В данном случае, если функция `getTotalProgressByRecutsion` получает на вход объект, она перебирает все его значения (которые могут быть как массивами, так и объектами) и для каждого из них вызывает саму себя. Это происходит во второй ветке условного оператора `if`.

Теперь давайте разберем, что происходит в строках:

```javascript
total[0] += subDataArr[0]; //нулевой индекс это общее значение
total[1] += subDataArr[1];
```

Здесь `total` — это массив, который хранит общий прогресс и общее количество студентов для текущего объекта. `subDataArr` — это массив, который возвращает рекурсивный вызов функции `getTotalProgressByRecutsion` для текущего подобъекта или подмассива. `subDataArr` содержит общий прогресс для подобъекта или подмассива, а `subDataArr[1]` содержит общее количество студентов.

Таким образом, `total += subDataArr` увеличивает общий прогресс на прогресс текущего подобъекта или подмассива, а `total[1] += subDataArr[1]` увеличивает общее количество студентов на количество студентов в текущем подобъекте или подмассиве.

В итоге, после перебора всех подобъектов и подмассивов, функция возвращает общий прогресс и общее количество студентов для текущего объекта. Эти значения затем используются на более высоких уровнях рекурсии для подсчета общего прогресса и общего количества студентов во всем исходном объекте `students`.
*/
