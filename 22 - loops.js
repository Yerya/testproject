"use strict";

let num = 50;

/* while: пока условие выполняется, производим какие то дейтсвия

если оставить как ниже, то цикл будет бескононечным, тк num будет всегда меньше 55

while (num < 55) {
  console.log(num);
}
поэтому,

пока наше условие не вернет false, выполняй такие то действия.
*/

while (num < 55) {
  console.log(num);
  num++; //увеличиваем на 1
}
//num теперь больше 54, выходим из цикла
console.log(num);

// do while: можно сначала заставить цикл что то сделать, а потом уже проверить условие и по необходимости выйти из цикла.
do {
  console.log(num);
  num++;
} while (num < 55);

/* ключевое слово for, в скобках условие, которое состоит из трех необязательных аргументов,
потом идет i,  с которой будем работать, потом условие, при котором цикл прекратит свою работу, 
и последнее это шаг цикла. В фигурных скобочках что будет делать цикл 

например цикл который выводит числа от 1 до 7

for (let i=1; i<8; i++) {
  console.log(i);
}

*/

// то есть ниже происходит: i = 0, num = 50, i = 2, num = 52, ... num = 55, i = 5;
for (let i = 0; num < 55; i++) {
  console.log(num);
  num++;
}
//Если переменная приняла какое то специфическое значение то можно закончить цикл досрочно с помощью break
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    break;
  }
  console.log(i);
}

//оператор continue позволяет пропустить ненужный шаг
for (let i = 0; i < 10; i++) {
  if (i === 5) {
    continue;
  }
  console.log(i);
}

// Циклы в цикле

/* Например, есть цикл, который постепенно перебирает данные, 
когда он натыкается на массив надо перебрать еще раз,
значит надо перебрать еще раз.*/

for (let i = 0; i < 3; i++) {
  console.log(i);

  for (let j = 0; j < 3; j++) {
    console.log(j);
  }
}

/* создать при помощи символа звездоски фигуру прямоугольника, 
тут мы на каждой итерации добавляем по одной звездочке и записываем результат 
в одну строку с переносом строки тоже на каждой итерации, чтобы все было в одной 
переменной.*/

let stars = "";
let result = "";
const numOfStrings = 7;

for (let i = 0; i < numOfStrings; i++) {
  stars += "*";
  result += stars + "\n";
}

console.log(result);

/* тоже самое при помощи вложенного цикла, создаем цикл для шагов, от 1 до 7 включительно,
чтобы получилось в итоге 7 шагов, на каждом шаге глобального цикла добавляем в result 
перенос строки. Внутри вложенного цикла j выполняется пока меньше i для каждой итерации
первого цикла пока выполняется условие j < 1, то есть i = 1, j = 0, j<i значит
добавляем в result звездочку,и вложенный цикл срабатывает только один раз тк отличается от i на единицу всегда.
и тк += то будет постоянно n+1. И так до момента i = 7, j будет 6 и выполнится, на следующем шаге цикл заканчивает свою работу. */

let result = "";
const numOfStrings = 7;

for (let i = 1; i <= numOfStrings; i++) {
  for (let j = 0; j < i; j++) {
    result += "*";
  }
  result += "\n";
}
console.log(result);

/*
Каждый день повторяется, внутри каждого дня повторяется приготовление пищи
и мытье посуды, но готовя ужин хочется просто все бросить и начать новый день с новыми
силами. То есть завершить 2 начатых цикла. В этом нам поможет continue.
То есть из внутреннего вложенного цикла сразу остановиться и перейти к следующей итерации
большего цикла

for (let i = 0; i < 3; i++) {
  console.log(`First level: ${i}`);

  for (let j = 0; j < 3; j++) {
    console.log(`Second level: ${j}`);

    for (let k = 0; k < 3; k++) {
      console.log(`Third level: ${k}`);
    }
  }
}

сделаем условие, что если k === 2, то самый внешний цикл начнем с новой итерации,
то есть закончим 2 внутренних и перейдем сразу к следующему. Нужна
метка для обозначения где останавливать, а где продолжать цикл.

Тк метка у нас на самый внешний цикл, то все внутренние тоже завершатся, а не только
там где поставили contineu

*/

first: for (let i = 0; i < 3; i++) {
  console.log(`First level: ${i}`);

  for (let j = 0; j < 3; j++) {
    console.log(`Second level: ${j}`);

    for (let k = 0; k < 3; k++) {
      if (k === 2) continue first; //та самая метка, назвали ее вначале.
      console.log(`Third level: ${k}`);
    }
  }
}

// тоже самое можно проделать и с break, который полностью будет останавливать цикл
first: for (let i = 0; i < 3; i++) {
  console.log(`First level: ${i}`);

  for (let j = 0; j < 3; j++) {
    console.log(`Second level: ${j}`);

    for (let k = 0; k < 3; k++) {
      if (k === 2) break first; //та самая метка, назвали ее вначале.
      console.log(`Third level: ${k}`);
    }
  }
}

//
