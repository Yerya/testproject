"use strict";
/* 
В выражении [ ] + false - null + true порядок выполнения операций будет следующим:
[ ] + false: Пустой массив [] преобразуется в пустую строку "", затем false преобразуется в строку "false". Конкатенация дает строку "false".
"false" - null: Строка "false" пытается преобразоваться в число, что дает NaN, так как строка "false" не может быть преобразовано в число. null преобразуется в 0. Операция вычитания с NaN всегда дает NaN.
NaN + true: true преобразуется в 1. Операция сложения NaN с любым числом дает NaN.
Итак, результатом выражения будет NaN. Если выполнить это в console.log, то в консоль будет выведено:
*/
console.log([3] + true); //строка 3true, тк массив преобразуется в строку
console.log([] + false - null + true); //строка 3true, тк массив преобразуется в строку

//

let y = 1;
let x = (y = 2);
console.log(x); //2 тк переопределился

//
console.log([] + 1 + 2); //строка 12, чек 40 практику файл

//

console.log("1"[0]); //строка 1 тк певый элемент это строка единица

// && возвращает первое false Значение если есть, либо последнее true Значение
// || возвращает последнее false Значение которое встречает, либо первое true значение
/* 
в этом есть логика, тк например в случае || Он должен найти любое true Значение, поэтому
должен пройтись по всем двум значениям в том числе и false, и возвращает последний false тк так и не нашел первое true,
Либо сразу первое true возвращает, тк нам надо ИЛИ то ИЛИ то.

также и с &&, ему нужно чтобы два операнда было true, поэтому если они true возвращает последний из них, добившись успеха,
но если один из них false То сразу его возвращает тк это уже не соответствует логике И (и значит что сразу 2 должно быть true).
*/
console.log(2 && 1 && null && 0 && undefined); //null

//

//есть ли разница между? да, в одном true, в другом 5, при этом если не задавать переменные будут ошибки
const a = 4;
const b = 5;
console.log(!!(a && b));
console.log(a && b);

//

//более приоритетный && даже без скобок
console.log(null || (2 && 3) || 4); //3

//

//Правда ли что a == b ? Нет, тк ссылки разные
a = [1, 2, 3];
b = [1, 2, 3];
console.log(a == b); //false, c === Тоже

//
console.log(+"Infinity"); //Infinity, тип данных число

//

//если две одинаковые буквы то берется следующая строка.
console.log("Ёжик" > "яблоко"); //false, Сравнение строк в JavaScript происходит посимвольно и использует коды Unicode символов. В Unicode, код для символа "Ё" меньше, чем код для символа "я". Поэтому, когда вы сравниваете "Ёжик" и "яблоко", сравнение останавливается на первом символе, потому что "Ё" меньше, чем "я", и возвращается false.
console.log("а" > "б"); //false Тоже
//

console.log(0 || "" || 2 || undefined || true || false); //2
