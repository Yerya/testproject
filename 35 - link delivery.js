"use strict";
//передача по ссылке или по значению

/*
При работе с примитивными типами, такими как
строка, число, логическое значение, то они передаются
по значению, а когда работаем с какими то объектами,
(массивы, функции и специфические функции в том числе),
то передача идет не по значению, а по ссылке.
*/

let a = 5,
  b = a;

b = b + 5;

console.log(b); //10
console.log(a); //5

const obj = {
  a: 5,
  b: 1,
};

const copy = obj; //передается не такой же объект obj, а ссылка на obj

copy.a = 10;

console.log(copy); //{ a: 10, b: 1 }
console.log(obj); //{ a: 10, b: 1 } //поэтому изменяется изначальный объект

//чтобы не модифицировать изначальный объект, создавая копию, существует несколько способов.
const obj2 = {
  a: 5,
  b: 1,
};

function copy(mainObj) {
  let objCopy = {};
  //создаст новый объект, перебирая свойства в старом.
  let key; //можно также let key сразу ниже
  for (key in mainObj) {
    objCopy[key] = mainObj[key]; //прошлись по свойствам старого объекта и поместили в новый
  }
  return objCopy;
}
//Ниже выводим результат в переменную, получился скопированный объект
// const copiedObj = copy(obj2);
// copiedObj.a = 101;

// console.log(obj2);
// console.log(copiedObj);

////

const numbers = {
  a: 2,
  b: 5,
  c: {
    x: 7,
    y: 4,
  },
};

const copiedObj2 = copy(numbers);
//таким образом, совершили клонирование, а не просто передали по ссылке, изначальный объекет не меняется в случае изменения этого
console.log(copiedObj2); //{ a: 2, b: 5, c: { x: 7, y: 4 } }
//НО! так как у мы прошлись в цикле только по первому уровню вложенности, переменная c передалась как ссылка и в случае изменения в одном объекте также будет изменена в другом.
//То есть мы создали поверхностную, а не глубокую копию объекта

// Метод Object.assign(): Этот метод копирует все перечисляемые собственные свойства из одного или нескольких исходных объектов в целевой объект.
// Это создает поверхностную копию объекта

const add = {
  d: 17,
  e: 20,
};
const spreadClone = {
  ...numbers,
  ...add,
  wow: "poluchilos",
};
console.log(spreadClone); //{ a: 2, b: 5, c: { x: 7, y: 4 }, d: 17, e: 20, wow: 'poluchilos' } копия через спреад оператор, тоже создает ПОВЕРХНОСТНУЮ! копию
console.log(numbers);
//создали поверхностную копию, которая не относится по ссылке ни к number Ни к add, это новый объект
console.log(Object.assign(numbers, add)); //{ a: 2, b: 5, c: { x: 7, y: 4 }, d: 17, e: 20 }
//чтобы создать просто копию, можно перым аргументом поместить пустой объект, то есть в него поместится второй объект
const clone = Object.assign({}, add);
clone.d = 10000;
console.log(clone); //{ d: 10000, e: 20 }
console.log(add); //{ d: 17, e: 20 }
//дословно assign - присваивать
//таким образом, Первый аргумент метода Object.assign() — это целевой объект, в который будут скопированы свойства из одного или нескольких исходных объектов, указанных в последующих аргументах.

//копия массива. Тоже, можно с помощью цикла, но можно и с помощью метда
const oldArray = ["a", "b", "с"];
// const newArray = oldArray.slice(0, 2); [ 'a', 'b' ] как и со всей стрингой, копирует весь массив, при этом можно задать конкретные start и end, чтобы скопировать например только часть. (тоже первое число это стартовый индекс, второе - конечный индекс не включительно, то есть больше на единицу)
const newArray = oldArray.slice();
newArray[1] = "uouo";
console.log(oldArray);
console.log(newArray);

//еще один способ, использование оператора разворота spread. Такой оператор есть в es 6 для массивов, в es 8 и для объектов
const video = ["youtube", "vimeo", "rutube"],
  blogs = ["wordpress", "livejournal", "blogger"],
  internet = [...video, ...blogs, "vk", "facebook"]; //такой синтаксис позволит взять переменные из предыдущих двух массивов и поместить в третий через запятую
console.log(internet);

//какая то функция логирования
function log(a, b, c, d) {
  console.log(a);
  console.log(b);
  console.log(c);
  console.log(d);
}
const num = [2, 5, 7]; //пришел допустим с сервера, а вместо данных могут быть данные о каком то видео, ссылка на источник, заглушку, автора
//и все эти 3 аргумента нам надо передать в функцию лог, тут и поможет спред оператор

log(...num); //то есть массив разложится на три отдельных элемента и функция запустится с этими тремя сущностями.
//четвертый аргумент для примера не использовали, возвращается андефайнд
// когда функция ожидает аргумент, который не был предоставлен при вызове функции, этот аргумент автоматически получает значение undefined.

//так и склонировали
const array = ["a", "b"],
  coooopy = [...array];
coooopy[0] = "newChar";
console.log(coooopy);
console.log(array);
